
## Overview: The JVM

Java uses a combination of compilation and interpretation. Java code is first compiled to bytecode format contained in `.class` files. This bytecode can be interpreted by any JVM on any platform. _Write Once Run Anywhere._

The JVM creates an isolated space on a the RAM of a host machine and uses this space to execute programs compiled to bytecode from any JVM language on any system. This is unlike languages such as C++ where code is compiled to platform specific instructions.

The JVM broadly consists of: A class loader subsystem, a runtime data area, and an execution area.

## The Class Loader Subsystem

During the execution of a program, the class loader subsystem loads the program's class files into memory. The JVM uses _dynamic class loading_. This means a class is loaded when the JVM finds a reference to it during runtime, and not at compile time. Class loading happens in three stages: loading, linking and initialization.

### 1. Loading

This is the process of taking the binary representation of classes (bytecode) and putting them into memory. The first class to be loaded is usually the class with the `static main(..)` method. All subsequent classes are loaded as references to them are found in the already loaded classes. The JVM has three in-built class loaders.

1. **Bootstrap Class Loader**: This loads classes in the Java standard library from `$JAVA_HOME/jre/lib/rt.jar`. It is the parent of the Extension class loader and sits at the root of the class loader hierarchy.

2. **Extension Class Loader**: This delegates loading request to it's parent, the Bootstrap Class Loader. And If delegation fails(i.e Bootstrap cannot load the classes), it tries to loads extensions of the Java standard libaries from `$JAVA_HOME/jre/lib/ext` or any other directory specified by `java.ext.dirs` system property.


3. **Application Class Loader**: This loads application class files from the system classpath which can be set using `-cp` or `-classpath`. It only attempts to load a class after unsuccessfully delegating to the Extension class loader. 


_NOTE: Class loaders first delegate to their parent and only attempt to load classes that their superclass cannot. If the last class loader in the hierarchy cannot find a class, one of `NoClassDefFoundError` or `ClassNotFoundException` is thrown._

_NOTE: Apart from the in-built class laoders User-Defined Class Loaders can be implemented in application code. This approach is used in web servers like Tomcat to make web apps run independently._

### 2. Linking

Linking is the process of verifying and preparing a loaded class. It happens in three stages:

1. **Verification:** This involves checking the validity of the class file. E.g is the code generated by a valid compiler? Is the Java version it was built for supported by the JVM?

2. **Preparation:** At this stage memory is allocated for static fields, and they are initialized with default values.

3. **Resolution:** Symbolic references to other classes are resolved at this stage.

### 3. Initialization

This is when the initialization logic of a class is executed. Constructors can be called, static code blocks are executed and static fields are assigned their values. This is the final stage of class loading.

## The Runtime Data Area

This consists of the five memory areas used by the JVM at run. 

1. **Method Area:** Class level data is stored here. This includes: static variables, method data(name, return type, etc.), runtime constant pool, field data, method and constructor code, etc. There is only one method area per JVM. If there is not enough memory available for this area, the JVM throws an `OutOfMemoryError`.

2. **Heap Area:** This is where objects live. There is only one of this per JVM.

3. **Stack Area:** A new runtime stack is created for every thread. Whenever a thread calls a method, an entry called a stack frame is pushed onto the runtime stack for the thread. Each stack frame stores local variables and other data needed to execute the method. When a method returns, or throws an exception, it's stack frame is removed. When a thread terminates, it's runtime stack is destroyed by the JVM. When there is insufficient memory for the runtime stack a thread requires, the JVM throws a `StackOverflowError`. When there is insufficient memory for the stack frame a method call requires, the JVM throws an `OutOfMemoryError`.

4. **Program Counter(PC) Registers:** The JVM creates a separate PC register for every new thread that starts. The PC register stores the address of the currently executing instruction i.e., a memory address in the method area. Once execution is done, the PC register is updated with the address of the next instruction. 

5. **Native method stack:** For every new thread that starts, the JVM also creates a native method stack to store native method information. Java supports calling methods written in another language, typically C/C++, through the Java Native Interface(JNI).

## The Execution Engine

The execution engine is responsible for actually executing the bytecode. It reads and writes data in the runtime data areas described above.

However before bytecode can be executed it has to be converted to machine language instructions for the OS. The JVM uses an interpreter or a JIT compiler to do this. The final component of the execution engine is the garbage collector which is used to automatically clean up dead objects.

1. **The Interpreter**

The interpreter reads and executes(i.e., convert to machine code and run) bytecode line by line. It can read a line of bytecode quickly, but execution is slower. And, each time a method is called, a new interpretation and execution is required.

2. **JIT compiler**

The JIT compiler compiles the bytecode to native code, stores it in the cache, and provides the native code as a method is called repeatedly, without needing to recompile. Native code execution is faster than bytecode interpretation and execution. 

However, bytecode compilation takes more time than line by line interpretation. Also, cache storage of native code is expensive. For a code segment that is called just once, it is better to interpret than to compile. The JIT compiler checks the frequency of method calls and decides to compile only when a method has been called a certain number of times.

3. **Garbage Collector**

The garbage collector removes frees up memory by removing unreferenced objects from the heap area.
Consider the following:

```java
SomeObject a = new SomeObject("first object");
a = new SomeObject("second object");
```

In the above code, the first object still exists even though there is no longer a reference to it. The GC will identify and remove objects like that otherwise the JVM will eventually run out of space in the heap.

Garbage collection happens automatically in two phases, `mark` and `sweep`. In the first phase the GC identifies unused objects. In the second phase it removes them. The GC can also be triggered by calling `System.gc()`, but it is not guaranteed that the JVM will honour this request.

##### References

* [Platform Engineer | Understanding Java Memory Model](https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973)
* [Platform Engineer | Understanding JVM Architecture](https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722)
* [FreeCodeCamp | JVM Tutorial](https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/)
